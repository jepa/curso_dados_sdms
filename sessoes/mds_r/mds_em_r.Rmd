---
title: "Modelos de distribuição de espécies em R usando o pacote biomod2"
author: "Juliano Palacios Abrantes"
date: "Última atualização `r Sys.Date()`"
output: 
  html_notebook: 
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: false
    theme: darkly
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
library(here)

source(paste0(here(),"/sessoes/funcoes_de_apoio/instalar_pacotes.R"))

packages <- c(
  "sf", # for loading shapefiles
  "sp",
  "tools", # for loading shapefiles
  "here", # for easy paths
  "rnaturalearth",
  "viridis", # color-blind friendly pallets
  "biomod2", 
  "raster",
  "janitor",
  "tidyverse",
  "tidyterra", # Para fazer plot das predictions
  "pROC" # para fazer plot de AUC
)

ipak(packages)

# Needs to convert to D2
# Fix new updates of sf package
sf::sf_use_s2(use_s2 = FALSE)

select <- dplyr::select

```


# Objectivo

Nesta sessao, aprenderemos como criar e avaliar modelos de distribuição de espécies (SDMs) usando o pacote `biomod2` em R. Ao final desta sessão, você deverá ser capaz de preparar seus dados, construir um modelo e visualizar os resultados.


# 1. Preparar dados

Para modelagem de distribuição de espécies, você precisará de dois componentes principais:

- Dados de Espécies (Presença-Ausência ou Contagens): Normalmente é um quadro de dados ou um conjunto de pontos com ocorrências de espécies (latitude, longitude) e as observações correspondentes (presença ou ausência).

- Dados Ambientais (Preditores): Conjunto de variáveis ambientais (e.g., temperatura, precipitação) que ajudam a modelar a distribuição das espécies. Geralmente são camadas rasterizadas.



## 1.1 Preparar dados ambientais

Você precisará de camadas ambientais para a região de interesse. Normalmente são camadas raster, que você pode carregar usando o pacote raster. Essas camadas podem ser dados climáticos (temperatura, precipitação, etc.), cobertura do solo, elevação, etc.

```{r}
# Carregar dados ambientais

# Lista de rasters individuais
raster_path <- list.files("../03_dados/02_variaveis/",
                          full.names = T,
                          pattern = ".tif")

raster_path

# Carrega todos os rasters juntos
env_data <- stack(raster_path)

# Vamos ver
plot(env_data)


```


## 1.2 Preparar dados de ocorrencia 

Prepare seus dados de ocorrência de espécies. Você deverá ter a latitude e longitude de cada ponto de ocorrência, bem como uma variável de resposta binária indicando se a espécie está presente ou não.

```{r}

# Carregar os dados de occorrencia

path_sf <- "../03_dados/01_ocorrencias/"

# The File
name_sf <- "occ_data_filter_edit.shp"

# Load it!
occ_sf <- st_read(dsn = path_sf,
                  layer =file_path_sans_ext(name_sf))

### TAMBEM FUNCIONA ASSIM
# occ_sf <- st_read("../03_dados/01_ocorrencias/occ_data_filter_edit.shp")

# Seleccionar occ
occ_data <- as.data.frame(occ_sf) %>% 
  select(longitd,latitud)

# extrair coordenadas
coordinates(occ_data) <- ~longitd + latitud


#Visualizar dados
ggplot(occ_sf) +
  geom_sf()

```


## 1.3 Formatar dados para o `BIOMOD`

Para construir o modelo, primeiro precisamos criar um objeto biomod2 usando a função BIOMOD_FormatingData. Esta função prepara os dados de espécies e dados ambientais para modelagem.


```{r}

biomod_data <- BIOMOD_FormatingData(
  resp.var = occ_data,
  expl.var = env_data,
  resp.name = "marmosops_incanus",
  PA.nb.rep = 3, # NUmber of batch pseudo absent (at least 3)
  PA.strategy = 'random'
)


```

# 2. Construçao do modelo

## 2.1 Opções globais do modelo (`BIOMOD_Modeling`)

Esta seção seleciona as diferentes opções que queremos incluir em nosso modelo. 

- *mds_algo*, observe que cada algoritmo tem suas próprias opções e configurações específicas para usuários mais avançados

- *n_rep*, Quanto mais dados, mais repetições, até certo ponto (por exemplo, 5-6 repetições). Duas já sao boas, mas pode ficar confuso. 10 é extremamente bom mas muitos dados a serem analizados.

- *data_sample*, representa a porcentagem de dados que você deseja usar para treinar o modelo. 

- *eval_metric*, voce pode utilizar *ROC*, *TSS*, ou ambas

- *model_thresh*, Determina o limite para seleção de "bons" modelos. Em geral, qualquer valor acima de 0,7 e bem recebido. Está relacionado ao `eval_metric`, enato precisa de um valor para cada metrica

```{r}
# Escolha os algoritmos a ser usados
mds_algo <- c('GLM','GAM',"ANN","RF")

# Número de repetições
n_rep <- 3 # Número de repetições que desejo (seleção aleatória de variáveis) 

# Porcentagem de dados para amostra
data_sample <- 70 

# Métrica de avaliação
eval_metric <- c("ROC","TSS")

# Opções globais BIOMOD_EnsembleModeling

# Limite de inclusão do modelo
model_thresh <- c(0.5, 0.5) 

```




## 2.2 Execução do modelo


Agora que os dados estão preparados, você pode executar vários modelos de distribuição de espécies usando o BIOMOD2. Suporta múltiplas técnicas de modelagem, incluindo MaxEnt, Random Forest, GLM e muito mais.



- *biomod_data*, é o objeto `biomod2` que você acabou de criar com a função `BIOMOD_FormatingData()`

- *modelos*, certifique-se de que mds_algo esteja definido corretamente. Deve ser um vetor de caracteres contendo os nomes dos modelos que você deseja usar (por exemplo, c("GLM", "RF", "MaxEnt")). As opções incluem: 'ANN', 'CTA', 'FDA', 'GAM', 'GBM', 'GLM', 'MARS', 'MAXENT', 'MAXNET', 'RF', 'SRE' ou 'XGBOOST


- *CV.strategy*,"random" é adequado para validação cruzada, mas certifique-se de ter dados para divisão.


- *CV.perc*, 0,7 significa que 70% dos dados serão usados para treinamento e 30% para validação. Certifique-se de que os dados sejam grandes o suficiente para suportar essa divisão.

- *CV.nb.rep*,

- *metric.eval*: Deve especificar as métricas que você deseja usar para avaliação, por exemplo, c("TSS", "ROC").


```{r}

# Criar nosso modelo
biomod_model <- BIOMOD_Modeling(
  bm.format = biomod_data,
  models = mds_algo,
  CV.strategy = "random",
  CV.perc = 0.7,
  CV.nb.rep	= 2,
  metric.eval = c('TSS','ROC')
)


```

## 2.3 Explore response curves

```{r}

# Plot response curve
env_window <- bm_PlotResponseCurves(
  biomod_model,
  fixed.var = 'mean',
  models.chosen = c("marmosops.incanus_PA1_RUN1_GAM",
                    "marmosops.incanus_PA2_RUN1_GAM"))

```

Sao tantos modelos que nao da pra entender nada, enao vamos fazer um pomedio dos melhores modelos

```{r}

# var_plot <-
as.data.frame(env_window$tab) %>% 
  # filter(pred.val < 0.99 & pred.val > 0.1 # so os melhores
  # ) %>%
  group_by(expl.name,expl.val) %>% 
  summarise_at(vars(pred.val),
               c(mean,sd),
               na.rm = T) %>% 
  ggplot() +
  geom_ribbon(
    aes(
      x = expl.val,
      ymax = fn1+fn2,
      ymin = fn1-fn2
    ),
    fill = "grey"
  ) +
  geom_line(
    aes(
      x = expl.val,
      y = fn1
    ),
    color = "black"
  ) +
  theme_classic() +
  labs(x = "Valores variavel explicativa",
       y = "Valores preditos") +
  facet_wrap(~expl.name, scales = "free", ncol = 3) 

```


## 2.4 Avaliações de modelo

Depois de executar os modelos, você pode avaliar seu desempenho usando diversas métricas de avaliação (por exemplo, AUC, TOC, etc.). biomod2 fornece automaticamente métricas de validação cruzada.

```{r}

# Avaliar o performance do modelo
biomod_model_evaluation <- get_evaluations(biomod_model)

# Mostrar resultados
print(biomod_model_evaluation)

```



```{r}
# Plot de ROC and TSS

# Fazer figura TSS vs ROC
bm_PlotEvalMean(biomod_model) 

```

## 2.5 Predições

After training and evaluating the models, you can project the models to other areas or future scenarios using new environmental data. This is particularly useful if you want to make predictions for other locations or future time points.


```{r}

# Identificar os modelos que tiveram melhor performance
well_peform_m <- biomod_model_evaluation %>% 
  filter(validation >= 0.7) %>% 
  pull(full.name)


# Faça previsões usando os modelos treinados
predictions_biomod <- BIOMOD_Projection(
  bm.mod = biomod_model,
  models.chosen = well_peform_m,
  new.env = env_data,  
  proj.name = "Prediction"
)

```

## 3.3 Explorar as predictions

```{r}

# Plotdas projeções (mapa de adequação do habitat previsto)
plot(predictions_biomod)

```


# 4. Modelos médios poderados

Aqui vamos fazer um modelo médio usando os modelos construidos na etapa anterior. O modelo médio será ponderado pelo TSS de cada um dos modelos.
```{r}
# Faça previsões médias usando os modelos treinados

model_ens <- BIOMOD_EnsembleModeling(
  bm.mod = biomod_model,
  models.chosen = well_peform_m,
  metric.select = "TSS", 
  em.by = "all")
```

## 4.1 Explore response curves

```{r}

# Plot response curve
env_window <- bm_PlotResponseCurves(
  model_ens,
  fixed.var = 'mean')

```


## 4.2 Avaliações de modelo

Depois de executar os modelos, você pode avaliar seu desempenho usando diversas métricas de avaliação (por exemplo, AUC, TOC, etc.). biomod2 fornece automaticamente métricas de validação cruzada.

```{r}

# Avaliar o performance do modelo
biomod_model_ens_evaluation <- get_evaluations(model_ens)

# Mostrar resultados
print(biomod_model_ens_evaluation)

```

## 4.3 Predições médias
```{r}

predictions_biomod_ens <- BIOMOD_EnsembleForecasting(
  bm.em = model_ens,
  new.env = env_data,
  proj.name = "ens_model"
)

plot(predictions_biomod_ens)
```



# Extra

## Criar Pseudo-Ausências

Se seus dados de observação consistem apenas em pontos de presença (ou seja, você não tem dados reais de ausência), é necessário criar pseudo-ausências para usar na modelagem de distribuição de espécies (SDM), especialmente quando deseja avaliar o modelo usando métricas de desempenho como AUC (Área Sob a Curva) ou curvas ROC (Receiver Operating Characteristic).

## Por que Criar Pseudo-Ausências?

Quando você tem apenas dados de presença, seu modelo não consegue diferenciar entre presença e ausência, pois não há pontos de ausência disponíveis. Na modelagem de distribuição de espécies, é necessário ter tanto dados de presença quanto de ausência para:
	-	Treinar o modelo (o algoritmo precisa aprender quais características estão correlacionadas com presença vs. ausência).
	-	Avaliar o desempenho do modelo (por exemplo, comparando as probabilidades preditas de presença vs. ausência).

Como você não tem ausências reais (ou seja, pontos onde a espécie não estava presente), pode gerar pseudo-ausências — dados artificiais de ausência com base em amostragem aleatória. Essas pseudo-ausências geralmente são selecionadas dentro da área ou região onde seus dados ambientais (por exemplo, camadas raster de clima, topografia) estão disponíveis.

## Etapa 1: Definir o Número de Pseudo-Ausências

Normalmente, cria-se um número igual de pseudo-ausências ao número de pontos de presença. No entanto, essa proporção pode ser ajustada dependendo do modelo ou da disponibilidade de dados. Por exemplo, você pode gerar pontos de pseudo-ausência em uma proporção de 1:1 ou 2:1, dependendo do modelo ou análise.

```{r}

# Let's assume you have 100 presence points:
n_presences <- nrow(occ_data)  # or length(occ_data) depending on how the presence data is structured

# You can generate the same number of pseudo-absences as presences:
n_absences <- n_presences  # Equal number of pseudo-absences

```

Etapa 2: Gerar Pseudo-Ausências Aleatórias

Você pode gerar pontos de pseudo-ausência aleatórios dentro da área de estudo (definida pelos seus dados ambientais). Por exemplo, se seus dados ambientais estiverem em formato raster, você pode extrair a extensão e amostrar pontos aleatórios dentro dessa área.


```{r}

# Suponha que você tenha 100 pontos de presença:
n_presences <- nrow(occ_data)  # ou length(occ_data), dependendo da estrutura dos dados

# Gerar o mesmo número de pseudo-ausências que presenças:
n_absences <- n_presences  # Número igual de pseudo-ausências

# Obter a extensão da área de estudo (dados ambientais)
env_extent <- extent(env_data)  # Substitua `env_data` pelo seu raster real

# Converter os dados de presença para um dataframe de coordenadas
occ_data_df <- as.data.frame(coordinates(occ_data))

# Extrair valores ambientais para os pontos de presença
presence_env_values <- extract(env_data, occ_data)

# Combinar coordenadas de presença com os valores ambientais
occ_data_df <- cbind(occ_data_df, presence_env_values)

# Definir uma semente para reprodutibilidade (opcional)
set.seed(123)

# Gerar coordenadas aleatórias dentro da extensão dos dados ambientais
random_coords <- cbind(
  runif(n_absences, env_extent@xmin, env_extent@xmax),
  runif(n_absences, env_extent@ymin, env_extent@ymax)
)

# Converter essas coordenadas para um objeto SpatialPoints
pseudo_absence_points <- SpatialPoints(random_coords, proj4string = CRS(proj4string(env_data)))

pseudo_absence_points

# Opcionalmente, verificar se os pontos caem dentro da área de estudo
plot(env_data)
points(pseudo_absence_points, col = "red")
plot(pseudo_absence_points)
```


## Etapa 3: Extrair Dados Ambientais para Pseudo-Ausências

Depois de gerar os pontos de pseudo-ausência, é necessário extrair os dados ambientais para esses pontos. Isso é importante porque os pontos de presença e pseudo-ausência devem conter as mesmas variáveis ambientais para serem comparáveis.

```{r}
# Extrair valores ambientais para as localizações de pseudo-ausência
pseudo_absence_values <- extract(env_data, pseudo_absence_points)

head(pseudo_absence_values)

# Opcionalmente, visualizar os pseudo-ausentes na área de estudo
plot(env_data)
points(pseudo_absence_points, col = "red")
```

## Etapa 4: Criar um Conjunto de Dados Combinado de Presença/Ausência

Agora que você tem os dados de presença e pseudo-ausência, pode combiná-los em um único conjunto de dados. Os pontos de presença serão rotulados como 1, e os pontos de pseudo-ausência serão rotulados como 0.

```{r}

# Criar um dataframe para pseudo-ausências, incluindo coordenadas e valores ambientais
pseudo_absence_df <- as.data.frame(random_coords)
colnames(pseudo_absence_df) <- c("longitude", "latitude")  # Renomear colunas para maior clareza

pseudo_absence_df <- cbind(pseudo_absence_df, pseudo_absence_values)

# Combinar os dados de presença e pseudo-ausência para variáveis ambientais
combined_occ_data <- rbind(occ_data_df, pseudo_absence_df)  # Combinar dados de ocorrência e pseudo-ausência

# Criar a variável de presença (assumindo que a presença é representada por 1)
presence_data <- rep(1, n_presences)

# Criar a variável de ausência (pseudo-ausências = 0)
absence_data <- rep(0, n_absences)

# Combinar as duas variáveis
combined_response <- c(presence_data, absence_data)

# Obter sistema de coordenadas
coords <- bind_cols(combined_occ_data$longitude, combined_occ_data$latitude)
colnames(coords) <- c("longitude", "latitude")

```
